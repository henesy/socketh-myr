// Server for SocketH-Myr

use std
use thread

// Handles incoming connections (one per connection)
const handler = {fd : std.fd
	var run = true

	while run
		var buf : byte[512]

		std.write(fd, "» ")

		// Core connection handler
		match std.read(fd, buf[:])
		| `std.Ok	0:
			break

		| `std.Ok	n:
			// Successful input line read

			// We truncate once we find one of {\0, \n, \r}
			var cnt
			for cnt = 0; cnt < n; cnt++
				match buf[cnt]
				| 0:
					break
				| 10:
					// \n
					break
				| 13:
					// \r
					break
				| _:
				;;
			;;
			
			var line = buf[:cnt]

			// Match input line
			match line
			| "!quit":
				// Close the client connection
				std.put("info: clean dc\n")
				std.write(fd, "Goodbye! ☺\n")
				std.close(fd)
				run = false
				break
			| "":
				// Empty line
				;
			| s:
				std.put("info: unknown cmd - {}\n", s)
			;;

		| `std.Err	e: 
			std.put("info: disconnected: {}\n", e)
			break
		;;

		std.nanosleep(5_000_000)
	;;

	std.put("info: end conn thread\n")
}

const listener = {addr : byte[:]
	var afd
	
	std.put("Address: {}\n", addr)
	std.put("Listening…\n")

	match std.announce(addr)
	| `std.Ok	f:	afd = f
	| `std.Err	e:	std.fatal("err: couldn't announce: {}\n", e)
	;;

	// Core listen loop
	while true
		match std.accept(afd)
		| `std.Ok	fd:
			thread.spawn({
				handler(fd)
			})

		| `std.Err	e:
			std.put("err: could not accept: {}\n", e)
			break
		;;

		std.nanosleep(5_000_000)
	;;
}

const main = {args : byte[:][:]
	// Print cmdline args
	for a : args
		std.put("arg = {}\n", a)
	;;

	var addr = "tcp!*!9090"

	thread.spawn({
		listener(addr)
	})

	while true
		std.nanosleep(5_000_000_000)
	;;
}
