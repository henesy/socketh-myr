// Server for SocketH-Myr

use std
use thread


const	maxconns	= 100			// Maximum open clients

var		connmtx		: thread.mutex	// Lock for conns[], I miss channels
var		conns		: std.fd[:]		// All open connections


// Sends a message to all connections
const sendmsg = {msg : byte[:]
	thread.mtxlock(&connmtx)
	
	for fd : conns
		std.write(fd, msg)
	;;
	
	thread.mtxunlock(&connmtx)
}

// Removes a fd from open connections
const delconn = {fd : std.fd
	thread.mtxlock(&connmtx)
	
	var i
	for i = 0; i < conns.len; i++
		if conns[i] == fd 
			// Cut the fd out
			var left = conns[:i]
			var right

			if i == (conns.len - 1)
				right = conns[:0]
			else
				right = conns[i+1:]
			;;
			
			std.slfree(conns)
			conns = std.sljoin(&left, right)
		;;
	;;
	
	thread.mtxunlock(&connmtx)
}

// Adds an fd to the open connections
const addconn = {fd : std.fd
	thread.mtxlock(&connmtx)
	
	conns = std.slpush(&conns, fd)
	
	thread.mtxunlock(&connmtx)
}

// Handles incoming connections (one per connection)
const handler = {fd : std.fd
	var username : byte[:]
	
	std.write(fd, "What is your username?: ")

	match std.read(fd, username[:])
	| `std.Ok	0:
		std.close(fd)
		-> void

	| `std.Ok	n:
		username = minimize(username[:n])
		addconn(fd)
		var msg = std.fmt("→ {}\n", username)
		std.put(msg)
		sendmsg(msg)

	| `std.Err	e: 
		std.put("err: couldn't read username\n")
		std.close(fd)
		-> void
	;;
	
	// Standard disconnect logic
	var dc = {
		std.close(fd)
		var msg = std.fmt("← {}\n", username)
		std.put(msg)
		sendmsg(msg)
		delconn(fd)
	}

	// Main chat loop
	while true
		var buf : byte[:]

		std.write(fd, "» ")

		// Core connection handler
		match std.read(fd, buf[:])
		| `std.Ok	0:
			// EOF
			dc()
			-> void

		| `std.Ok	n:
			// Successful input line read
			buf = buf[:n]
			var line = minimize(buf)

			// Match input line
			match line
			| "!quit":
				// Close the client connection
				std.put("info: clean dc\n")
				std.write(fd, "Goodbye! ☺\n")
				dc()
				-> void
			| "":
				// Empty line
				;
			| s:
				// Chat message
				var msg = std.fmt("{} : {}\n", username, minimize(s))
				std.put(msg)
				sendmsg(msg)
			;;

		| `std.Err	e: 
			std.put("info: hard dc: {}\n", e)
			dc()
			-> void
		;;

		std.nanosleep(5_000_000)
	;;
}


const main = {args : byte[:][:]
	// Print cmdline args
	for a : args
		std.put("arg = {}\n", a)
	;;

	var addr = "tcp!*!9090"
	
	conns = std.slalloc(maxconns)

	thread.spawn({
		listener(addr)
	})

	// Main spin loop
	while true
		std.nanosleep(5_000_000_000)
	;;
}


const listener = {addr : byte[:]
	var afd
	
	std.put("Address: {}\n", addr)
	std.put("Listening…\n")

	match std.announce(addr)
	| `std.Ok	f:	afd = f
	| `std.Err	e:	std.fatal("err: couldn't announce: {}\n", e)
	;;

	// Core listen loop
	while true
		match std.accept(afd)
		| `std.Ok	fd:
			thread.spawn({
				handler(fd)
			})

		| `std.Err	e:
			std.put("err: could not accept: {}\n", e)
			-> void
		;;

		std.nanosleep(5_000_000)
	;;
}

// Minimize the input line
const minimize = {buf : byte[:]
	// We truncate once we find one of {\0, \n, \r}
	var cnt
	for cnt = 0; cnt < buf.len; cnt++
		match buf[cnt]
		| 0:
			break
		| 10:
			// \n
			break
		| 13:
			// \r
			break
		| _:
		;;
	;;
	
	-> buf[:cnt]
}